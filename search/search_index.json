{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tiler","text":"<p>Please note, this is not an official Google repository. It is a Kotlin multiplatform experiment that makes no guarantees about API stability or long term support. None of the works presented here are production tested, and should not be taken as anything more than its face value.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Tiling is a state based paging implementation that presents a sublist of paged dataset in a simple <code>List</code>. It offers constant time access to items at indices, and the ability to introspect the items paged through.</p> <p>The following are examples of paged UI/UX paradigms that were built using tiling:</p> Basic pagination Pagination with sticky headers Pagination with search Pagination with placeholders <p>For large screened devices:</p> Pagination with adaptive layouts Pagination with adaptive layouts, search and placeholders <p>Tiling is achieved with a Tiler; a pure function that has the ability to adapt any generic method of the form:</p> <pre><code>fun &lt;T&gt; items(query: Query): Flow&lt;List&lt;T&gt;&gt;\n</code></pre> <p>into a paginated API.</p> <p>It does this using a <code>Tiler</code>:</p> <pre><code>fun interface ListTiler&lt;Query, Item&gt; {\nfun produce(inputs: Flow&lt;Tile.Input&lt;Query, Item&gt;&gt;): Flow&lt;TiledList&lt;Query, Item&gt;&gt;\n}\n</code></pre> <ul> <li>The inputs modify the queries for data</li> <li>The output is the data returned over time in a <code>List</code> implementation: A <code>TiledList</code>.</li> </ul> <p>Typical use of Tiling is the <code>toTiledList</code> extension on a <code>Flow&lt;Query&gt;</code>:</p> <p><pre><code>val pageRequestFlow = MutableSharedFlow&lt;Tile.Input&lt;Int, Item&gt;&gt;()\nval items: Flow&lt;TiledList&lt;Int, Item&gt;&gt; = pageRequestFlow.toTiledList(\nlistTiler(\norder = Tile.Order.Sorted(\ncomparator = compareBy(Int::compareTo)\n),\nlimiter = Tile.Limiter(\nmaxQueries = 3\n),\nfetcher = { page -&gt;\nrepository.itemsFor(page)\n}\n)\n)\n</code></pre> Requests for pages are sent on each emission of <code>pageRequestFlow</code>:</p> <pre><code>// Request page 1\npageRequestFlow.emit(Tile.Request.On(1))\n// Request page 5\npageRequestFlow.emit(Tile.Request.On(5))\n// Stop updates from page 1\npageRequestFlow.emit(Tile.Request.Off(1))\n// Delete cached results from page 1\npageRequestFlow.emit(Tile.Request.Evict(1)) </code></pre> <p>For most practical purposes, the <code>TiledList</code> produced should be anchored or \"pivoted\" around a particular page; typically the user's scroll position. For how to implement this with the library, see the basic example.</p>"},{"location":"#get-it","title":"Get it","text":"<p><code>Tiler</code> is available on mavenCentral with the latest version indicated by the badge at the top of this readme file.</p> <p><code>implementation com.tunjid.tiler:tiler:version</code></p>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2021 Google LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"implementation/performance/","title":"Efficiency &amp; performance","text":""},{"location":"implementation/performance/#general-tiling","title":"General Tiling","text":"<p>As tiling loads from multiple flows simultaneously, performance is a function of 2 things:</p> <ul> <li>How often the backing <code>Flow</code> for each <code>Input.Request</code> emits</li> <li>The time and space complexity of the transformations applied to the   output <code>TiledList&lt;Query, Item&gt;</code>.</li> </ul> <p>In the case of a former, the <code>Flow</code> should only emit if the backing dataset has actually changed. This prevents unnecessary emissions downstream.</p> <p>In the case of the latter, use <code>PivotRequest(on = x)</code> and <code>Input.Limiter</code> to match the output <code>TiledList</code> to the size of the view port of the user's device to create an efficient paging pipeline.</p> <p>For example if tiling is done for the UI, with a viewport that can display 20 items at once:</p> <ul> <li>20 items can be fetched per page</li> <li>100 items (20 * 5 pages) can be observed at concurrently</li> <li><code>Input.Limiter.List(maxQueries = 3)</code> can be set so only changes to the visible 60 items will be   sent to the UI at once.</li> </ul> <p>The items can be transformed with algorithms of <code>O(N)</code> to <code>O(N^2)</code> time and space complexity trivially as regardless of the size of the actual paginated set, only 60 items will be transformed at any one time.</p>"},{"location":"implementation/performance/#mutabletiledlist","title":"MutableTiledList","text":"<p>The performance of each method for the default <code>MutableTiledList</code> implementation is comparable to the cost of the same method in an <code>ArrayList</code> + O(log(T)) where T is the number of <code>Tile</code> instances (queries/pages) in the <code>TiledList</code>. This makes them perfect for use in recycling and scrolling containers.</p>"},{"location":"implementation/pivoted-tiling/","title":"Pivoting","text":""},{"location":"implementation/pivoted-tiling/#how-to-page-with-tiling","title":"How to page with Tiling","text":"<p>While the tiling API lets you assemble a paging pipeline from scratch using its primitives, the easiest scalable pagination approach with tiling is through the pivoting algorithm.</p> <p>Consider a large, possibly infinite set of paginated data where a user is currently viewing page p, and n is the buffer zone - the number of pages lazy loaded in case the user wants to visit it.</p> <pre><code>[..., p - n, ..., p - 1, p, p + 1, ..., p + n, ...]\n</code></pre> <p>As the user moves from page to page, items can be refreshed around the user's current page while allowing them to observe immediate changes to the data they're looking at.</p> <p>This is expanded in the diagram below:</p> <pre><code>[out of bounds]                        -&gt; Evict from memory\n                                _\n[p - n - 1 - n]                  |\n...                              | -&gt; Keep pages in memory, but don't observe\n[p - n - 1]          _          _|                        \n[p - n]               |\n...                   |\n[p - 1]               |\n[p]                   |  -&gt; Observe pages     \n[p + 1]               |\n...                   |\n[p + n]              _|         _\n[p + n + 1]                      |\n...                              | -&gt; Keep pages in memory, but don't observe\n[p + n + 1 + n]                 _|\n\n[out of bounds]                        -&gt; Evict from memory\n</code></pre> <p><code>n</code> is an arbitrary number that may be defined by how many items are visible on the screen at once. It could be fixed, or variable depending on conditions like the available screen real estate.</p> <p>For an example where <code>n</code> is a function of grid size in a grid list, check out ArchiveLoading.kt in the me project.</p> <p>The above algorithm is called \"pivoting\" as items displayed are pivoted around the user's current scrolling position.</p> <p>Since tiling is dynamic at it's core, a pipeline can be built to allow for this dynamic behavior by pivoting around the user's current position with the grid size as a dynamic input parameter.</p>"},{"location":"implementation/primitives/","title":"Primitives","text":""},{"location":"implementation/primitives/#api-surface-and-tiling-primitives","title":"API surface and Tiling primitives","text":"<p>Given a <code>Flow</code> of <code>Tile.Input</code>, tiling transforms them into a <code>Flow&lt;TiledList&lt;Query, Item&gt;&gt;</code> with a <code>ListTiler</code>.</p> <p>The resulting <code>TiledList</code> should be kept at a size that covers approximately 3 times the viewport. This is typically at or under 100 items for non grid UIs. You can then transform this list however way you want.</p>"},{"location":"implementation/primitives/#managing-requested-data","title":"Managing requested data","text":"<p>A tiled pagination pipeline is managed by the <code>Tile.Input</code> it receives. These inputs drive the dynamism of the pipeline. The following is a breakdown of them all.</p>"},{"location":"implementation/primitives/#inputrequest","title":"<code>Input.Request</code>","text":"<ul> <li> <p><code>Tile.Request.On</code>: Analogous to <code>put</code> for a <code>Map</code>, this starts collecting from the backing <code>Flow</code>   for the specified <code>query</code>. It is   idempotent; multiple requests have no side effects for loading, i.e the same <code>Flow</code> will not be   collect twice.</p> </li> <li> <p><code>Tile.Request.Off</code>: Stops collecting from the backing <code>Flow</code> for the specified <code>query</code>. The items   previously fetched by this query   are still kept in memory and will be in the <code>TiledList</code> of items returned. Requesting this is   idempotent; multiple requests   have no side effects.</p> </li> <li> <p><code>Tile.Request.Evict</code>: Analogous to <code>remove</code> for a <code>Map</code>, this stops collecting from the   backing <code>Flow</code> for the specified <code>query</code> and   also evicts the items previously fetched by the <code>query</code> from memory. Requesting this is   idempotent; multiple requests   have no side effects.</p> </li> </ul>"},{"location":"implementation/primitives/#tilebatch","title":"<code>Tile.Batch</code>","text":"<p>Used for dispatching multiple <code>Tile.Input</code> instances. The <code>ListTiler</code> may emit <code>TiledList</code> instances during the application of a <code>Tile.Batch</code> input; it is not transactional. Rather, it is an encapsulation of an aggregate of <code>Tile.Input</code> that represents a single logical operation. Users of the library may also define arbitrary <code>Tile.Batch</code> instances and use them in their tiled pipelines.</p>"},{"location":"implementation/primitives/#pivot","title":"<code>Pivot</code>","text":"<p>An implementation of <code>Tile.Batch</code>, this allows for returning a <code>TiledList</code> from results around a particular <code>Query</code>. It's use must be accompanied by a <code>Tile.Order.PivotSorted</code>.</p>"},{"location":"implementation/primitives/#tileinputlimiter","title":"<code>Tile.Input.Limiter</code>","text":"<p>Can be used to select a subset of items tiled instead of the entire paginated set. For example, assuming 1000 items have been fetched, there's no need to send a 1000 items to the UI for diffing/display when the UI can only show about 30 at once. The <code>Limiter</code> allows for selecting an arbitrary amount of items as the situation demands.</p>"},{"location":"implementation/primitives/#tileinputorder","title":"<code>Tile.Input.Order</code>","text":"<p>Defines the heuristic for selecting tiled items into the output <code>TiledList</code>.</p> <ul> <li> <p>Sorted: Sort items with a specified query <code>comparator</code>.</p> </li> <li> <p>PivotSorted: Sort items with the specified <code>comparator</code> but pivoted around a specific <code>Query</code>.   This allows for showing items that have more priority over others in the current context   like example in a list being scrolled. In other words assume tiles have been fetched for queries   1 - 10 but a   user can see pages 5 and 6. The UI need only to be aware of pages 4, 5, 6, and 7. This allows for   a rolling window of   queries based on a user's scroll position.</p> </li> </ul>"},{"location":"implementation/tiledlist/","title":"Tiled lists","text":"<p>A <code>TiledList</code> is a <code>List</code> that:</p> <ul> <li>Is a sublist of the items in the backing data source.</li> <li>Allows for looking up the query that fetched each item.</li> </ul> <p>The latter is done by associating a range of indices in the <code>List</code> with a <code>Tile</code>. Effectively, a <code>TiledList</code> \"chunks\" its items by query. For example, the <code>TiledList</code> below is a <code>List</code> with 10 items, and two tiles. Each <code>Tile</code> covers 5 indices:</p> <pre><code>|     1      |        2      |\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre> <p>A <code>Tile</code> is a <code>value</code> class with the following public properties:</p> <pre><code>value class Tile(...) {\n// start index for a chunk\nval start: Int\n// end exclusive index for a chunk\nval end: Int\n}\n</code></pre> <p>A <code>TiledList</code> is defined as:</p> <pre><code>interface TiledList&lt;Query, Item&gt; : List&lt;Item&gt; {\n/**\n     * The number of [Tile] instances or query ranges there are in this [TiledList]\n     */\nval tileCount: Int\n/**\n     * Returns the [Tile] at the specified tile index.\n     */\nfun tileAt(tileIndex: Int): Tile\n/**\n     * Returns the query at the specified tile index.\n     */\nfun queryAtTile(tileIndex: Int): Query\n/**\n     * Returns the query that fetched an [Item] at a specified index.\n     */\nfun queryAt(index: Int): Query\n}\n</code></pre> <p><code>MutableTiledList</code> instances also exist:</p> <pre><code>interface MutableTiledList&lt;Query, Item&gt; : TiledList&lt;Query, Item&gt; {\nfun add(index: Int, query: Query, item: Item)\nfun add(query: Query, item: Item): Boolean\nfun addAll(query: Query, items: Collection&lt;Item&gt;): Boolean\nfun addAll(index: Int, query: Query, items: Collection&lt;Item&gt;): Boolean\nfun remove(index: Int): Item\n}\n</code></pre> <p>This is useful for modifying <code>TiledList</code> instances returned. Actions like:</p> <ul> <li>Inserting separators or other interstitial content</li> <li>Mapping items with in memory data after fetching from a database</li> <li>General list modification</li> </ul> <p>can be easily performed.</p>"},{"location":"usecases/adaptive-paging/","title":"Adaptive Paging","text":"<p>The following guide helps create the UI/UX seen below:</p> <p> </p>"},{"location":"usecases/adaptive-paging/#guide","title":"Guide","text":"<p>Situations can arise that can require more dynamic pagination. Consider paging for an adaptive layout. The items fetched can be a function of:</p> <ul> <li>A UI that can change in size, requiring more items to fit the view port.</li> <li>A user wanting to change the sort order.</li> </ul> <p>A pivoting pipeline for the above looks like:</p> <pre><code>// Query for items describing the page and sort order\ndata class PageQuery(\nval page: Int,\nval isAscending: Boolean\n)\nclass Loader(\nisDark: Boolean,\nscope: CoroutineScope\n) {\n// Current query that is visible in the view port\nprivate val currentQuery = MutableStateFlow(\nPageQuery(\npage = 0,\nisAscending = true\n)\n)\n// Number of columns in the grid\nprivate val numberOfColumns = MutableStateFlow(1)\n// Flow specifying the pivot configuration\nprivate val pivotRequests = combine(\ncurrentQuery.map { it.isAscending },\nnumberOfColumns,\n::pivotRequest\n).distinctUntilChanged()\n// Define inputs that match the current pivoted position\nprivate val pivotInputs = currentQuery.toPivotedTileInputs&lt;PageQuery, NumberTile&gt;(\npivotRequests = pivotRequests\n)\n// Allows for changing the order on response to user input\nprivate val orderInputs = currentQuery\n.map { pageQuery -&gt;\nTile.Order.PivotSorted&lt;PageQuery, NumberTile&gt;(\nquery = pageQuery,\ncomparator = when {\npageQuery.isAscending -&gt; ascendingPageComparator\nelse -&gt; descendingPageComparator\n}\n)\n}\n.distinctUntilChanged()\n// Change limit to account for dynamic view port size\nprivate val limitInputs = numberOfColumns.map { gridSize -&gt;\nTile.Limiter&lt;PageQuery, NumberTile&gt; { items -&gt; items.size &gt; MIN_ITEMS_TO_SHOW * gridSize }\n}\nval tiledList: Flow&lt;TiledList&lt;PageQuery, NumberTile&gt;&gt; = merge(\npivotInputs,\norderInputs,\nlimitInputs,\n)\n.toTiledList(\nnumberTiler(\nitemsPerPage = ITEMS_PER_PAGE,\nisDark = isDark,\n)\n)\nfun setCurrentPage(page: Int) = currentQuery.update { query -&gt;\nquery.copy(page = page)\n}\nfun toggleOrder() = currentQuery.update { query -&gt;\nquery.copy(isAscending = !query.isAscending)\n}\nfun setNumberOfColumns(numberOfColumns: Int) = this.numberOfColumns.update {\nnumberOfColumns\n}\n// Avoid breaking object equality in [PivotRequest] by using vals\nprivate val nextQuery: PageQuery.() -&gt; PageQuery? = {\ncopy(page = page + 1)\n}\nprivate val previousQuery: PageQuery.() -&gt; PageQuery? = {\ncopy(page = page - 1).takeIf { it.page &gt;= 0 }\n}\n/**\n   * Pivoted tiling with the grid size as a dynamic input parameter\n   */\nprivate fun pivotRequest(\nisAscending: Boolean,\nnumberOfColumns: Int,\n) = PivotRequest(\nonCount = 4 * numberOfColumns,\noffCount = 4 * numberOfColumns,\nnextQuery = nextQuery,\npreviousQuery = previousQuery,\ncomparator = when {\nisAscending -&gt; ascendingPageComparator\nelse -&gt; descendingPageComparator\n}\n)\n}\nprivate fun numberTiler(\nitemsPerPage: Int,\nisDark: Boolean,\n): ListTiler&lt;PageQuery, NumberTile&gt; =\nlistTiler(\nlimiter = Tile.Limiter { items -&gt; items.size &gt; 40 },\norder = Tile.Order.PivotSorted(\nquery = PageQuery(page = 0, isAscending = true),\ncomparator = ascendingPageComparator\n),\nfetcher = { pageQuery -&gt;\npageQuery.colorShiftingTiles(itemsPerPage, isDark)\n}\n)\nfun PageQuery.colorShiftingTiles(itemsPerPage: Int, isDark: Boolean): Flow&lt;List&lt;NumberTile&gt;&gt; {\n...\n}\n</code></pre> <p>In the above, only flows for 4 * numOfColumns queries are collected at any one time. 4 * numOfColumns more queries are kept in memory for quick resumption, and the rest are evicted from memory. As the user scrolls, <code>setCurrentPage</code> is called, and data is fetched for that page, and the surrounding pages. Pages that are far away from the defined range are removed from memory.</p>"},{"location":"usecases/basic-example/","title":"Basic example","text":"<p>The following guide should help create the UI/UX seen below:</p> <p> </p>"},{"location":"usecases/basic-example/#guide","title":"Guide","text":"<p>Imagine a social media feed app backed by a <code>FeedRepository</code>. Each page in the repository returns 30 items. A pivoted tiling pipeline for it can be assembled as follows:</p> <pre><code>class FeedState(\nrepository: FeedRepository\n) {\nprivate val requests = MutableStateFlow(0)\nprivate val comparator = Comparator(Int::compareTo)\n// A TiledList is a regular List that has information about what\n// query fetched an item at each index\nval feed: StateFlow&lt;TiledList&lt;Int, FeedItem&gt;&gt; = requests\n.toPivotedTileInputs&lt;Int, FeedItem&gt;(\nPivotRequest(\n// 5 pages are fetched concurrently, so 150 items\nonCount = 5,\n// A buffer of 2 extra pages on either side are kept, so 210 items total\noffCount = 2,\ncomparator = comparator,\nnextQuery = {\nthis + 1\n},\npreviousQuery = {\n(this - 1).takeIf { it &gt;= 0 }\n}\n)\n)\n.toTiledList(\nlistTiler(\n// Start by pivoting around 0\norder = Tile.Order.PivotSorted(\nquery = 0,\ncomparator = comparator\n),\n// Limit to only 3 pages of data in UI at any one time, so 90 items\nlimiter = Tile.Limiter(\nmaxQueries = 3,\nitemSizeHint = null,\n),\nfetcher = { page -&gt;\n// The fetcher returns a flow, this allows for self updating pages  \nflow { emit(repository.getPage(page)) }\n}\n)\n)\n.stateIn(/*...*/)\nfun setVisiblePage(page: Int) {\nrequests.value = page\n}\n}\n</code></pre>"},{"location":"usecases/complex-tiling/","title":"Adaptive Paged Search with Placeholders","text":"<p>The following guide should help create the UI/UX seen below:</p> <p> </p> <p>See the <code>ArchiveList</code> state production pipeline in the me github project for an example of a a complex tiled pagination pipeline with key preservation across multiple queries. In it, the current item the user is viewing can remain anchored even as the search filter changes.</p>"},{"location":"usecases/complex-tiling/#guide","title":"Guide","text":"<p>In your application you may have scenarios that are a combination of all the use cases covered:</p> <ul> <li>Adapts to different screen sizes</li> <li>Uses placeholders</li> <li>Implements search</li> <li>Requires extra transformations</li> </ul> <p>In situations like this, the preceding sections still apply. Each use case is independent by and large. That said, the most difficult issue faced with combined use cases is key preservation.</p>"},{"location":"usecases/complex-tiling/#key-preservation","title":"Key preservation","text":"<p>In UIs, keys provide unique tokens to represent individual items in lists. This is necessary for scroll state preservation and animations. In a tiled paging pipeline where items change due to:</p> <ul> <li>Placeholders being replaced</li> <li>Items being sorted or reordered differently</li> <li>Generic items being replaced</li> <li>Search queries changing</li> </ul> <p>The best way to preserve keys across these changes is to maintain a snapshot of the old list, and when the new list arrives, preserve the keys in the old list in the new list by defining a way to identify them in the new list.</p>"},{"location":"usecases/complex-tiling/#on-each-query","title":"On each query...","text":"<p>In a range of items in a query/page that has 20 items:</p> <ul> <li>First generate 20 unique ids for all items in that range.</li> <li>Create placeholders that use those ids and emit them.</li> <li>Asynchronously load and emit new items, and use the same ids for the placeholders in those items.</li> </ul>"},{"location":"usecases/complex-tiling/#on-each-tiledlist-emission","title":"On each <code>TiledList</code> emission...","text":"<ul> <li>Keep a reference to the current list presented in the UI</li> <li>When the new <code>TiledList</code> is emitted, compare the old list to the new list</li> <li>If the old list has items that are not placeholders that are present in the new list, replace the   ids in the new list with the ids from the old list.</li> <li>Make sure ids are not duplicated.</li> </ul> <p>The steps above will allow you to achieve smooth item animations in complex pagination pipelines.</p>"},{"location":"usecases/compose/","title":"Jetpack Compose","text":""},{"location":"usecases/compose/#pivoting-with-jetpack-compose","title":"Pivoting with Jetpack Compose","text":"<p>Pivoted tiling in Jetpack Compose is done using the <code>PivotedTilingEffect</code>:</p> <pre><code>@Composable\nfun Feed(\nstate: FeedState\n) {\nval feed by state.feed.collectAsState()\nval lazyState = rememberLazyListState()\nLazyColumn(\nstate = lazyState,\ncontent = {\nitems(\nitems = feed,\nkey = FeedItem::key,\nitemContent = { /*...*/ }\n)\n}\n)\nlazyState.PivotedTilingEffect(\nitems = feed,\n// Update the user's current visible query\nonQueryChanged = { page -&gt; if (it != null) state.setVisiblePage(page) }\n)\n}\n</code></pre> <p>As the user scrolls, <code>setVisiblePage</code> is called to keep pivoting about the current position.</p>"},{"location":"usecases/compose/#unique-keys","title":"Unique keys","text":"<p>Tiling collects from each <code>Flow</code> for all queries that are on concurrently. For pagination from a database where items can be inserted, items may be duplicated in the produced <code>TIledList</code>.</p> <p>For example consider a DB table consisting of tasks sorted by ascending date:</p> id date task ... 0998 01/01/23 Go for a jog 0999 01/04/23 Print shipping labels ... <p>Assuming 20 items per query, tasks 0980 - 0999 will be contained in a query for page 50.</p> <p>Assume a new task for \"Check invoices\" with id 1000 is entered for date 01/03/23:</p> id date task ... 0998 01/01/23 Go for a jog 1000 01/03/23 Check invoices 0999 01/04/23 Print shipping labels ... <p>There are now 51 pages of tasks. When page 51 emits:</p> <ul> <li>It will contain the last task alone; task 099 \"Print shipping labels\".</li> <li>Page 50 will still have its last emitted tasks 0980 - 0999, including \"Print shipping labels\".</li> <li>At some point in the future, page 50 will update to contain the new task 1000 \"Check invoices\" and   exclude task 0999 - \"Print shipping labels\".</li> </ul> <p>Until page 50 updates, task 0999 \"Print shipping labels\" will be duplicated in the list. To address this, the produced <code>TiledList</code> will need to be filtered for duplicates since keys must be unique in Compose lazy layouts and indices cannot be used for keys without losing animations.</p> <p>This is easily done using <code>TiledList.distinct()</code> or <code>TiledList.distinctBy()</code>. The cost of this fixed since a <code>TiledList</code> is a sublist of the entire collection. Using a pivoted tiling pipeline where 5 queries are kept on, but 3 queries are presented to the UI at any one time (using <code>Tile.Limiter</code>), the fixed cost for de-duplicating items for every change in the data set is O(60).</p> <p>Note: Page 51 is not guaranteed to have emitted first. Any query can emit at anytime when tiling. Tiling presents snapshots of the paging pipeline at a single point in time. It is not opinionated about the data contained. It only guarantees ordering of the queries according to the <code>Tile.Order</code> specified in the tiling configuration. This makes it flexible enough for post processing of data like filtering, debouncing, mapping and so on.</p>"},{"location":"usecases/compose/#sticky-headers","title":"Sticky headers","text":"<p>For a <code>LazyList</code> in Compose, sticky headers can be implemented using the following:</p> <pre><code>// This ideally would be done in the ViewModel\nval grouped = contacts.groupBy { it.firstName[0] }\n@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun ContactsList(grouped: Map&lt;Char, List&lt;Contact&gt;&gt;) {\nLazyColumn {\ngrouped.forEach { (initial, contactsForInitial) -&gt;\nstickyHeader {\nCharacterHeader(initial)\n}\nitems(contactsForInitial) { contact -&gt;\nContactListItem(contact)\n}\n}\n}\n}\n</code></pre> <p>When paging with a <code>TiledList</code>, grouping can still be performed. If you do not need <code>TiledList</code> metadata on the grouped data use <code>List.groupBy()</code>, otherwise use <code>TiledList.groupBy()</code> which will return a <code>Map&lt;Key, TiledList&lt;Query, Item&gt;</code>.</p>"},{"location":"usecases/overview/","title":"Overview","text":"<p>As tiling is a pure function that operates on a reactive stream, its configuration can be changed on the fly. This lends it well to the following situations:</p> <ul> <li> <p>Offline-first apps: Tiling delivers targeted updates to only queries that have changed. This works   well for   apps which write to the database as the source of truth, and need the UI to update immediately.   For example   a viral tweet whose like count updates several times a second.</p> </li> <li> <p>Adaptive pagination: The amount of items paginated through can be adjusted dynamically to account   for app window   resizing by turning on more pages and increasing   the   limit of data sent to the UI from the paginated   data available.   An example is in   the Me   app.</p> </li> <li> <p>Dynamic sort order: The sort order of paginated items can be changed cheaply on a whim by changing   the   order as this only operates on the data output from   the tiler, and not   the entire paginated data set. An example is in the sample in this   repository.</p> </li> </ul>"},{"location":"usecases/pagination-types/","title":"Pagination types and Tiling","text":"<p>The following guide details how tiling may be used for</p> <ul> <li>Offset pagination</li> <li>Key set/cursor pagination</li> </ul>"},{"location":"usecases/pagination-types/#offset-pagination","title":"Offset pagination","text":"<p>To use offset pagination with Tiling, embed the offset and limit required in each query specified. For example, a <code>PageQuery</code> with 20 items per page mey be specified as:</p> <pre><code>data class PageQuery(\nval offset: Int,\nval limit: Int = 20,\n)\n</code></pre>"},{"location":"usecases/pagination-types/#example","title":"Example","text":"<p>Each <code>Flow</code> used in the <code>ListTiler</code> function should emit if the range it covers changes. Consider the example below:</p> <pre><code>listTiler(\norder = Tile.Order.PivotSorted(\nquery = startQuery,\ncomparator = compareBy(PageQuery::offset)\n),\nlimiter = Tile.Limiter(\nmaxQueries = 3\n),\nfetcher = { query -&gt;\nrepository.itemsForPage(query)\n}\n)\n</code></pre> <p>In the above, <code>repository.itemsForPage</code> may delegate to a SQL backed data source with the following query:</p> <pre><code>SELECT *\nFROM items\nLIMIT :limit\nOFFSET :offset;\n</code></pre>"},{"location":"usecases/pagination-types/#key-set-and-cursor-based-pagination","title":"Key set and cursor based pagination","text":"<p>Some pagination pipelines need the result of an adjacent page to fetch consecutive pages. This is common with SQL databases with ordered or indexed <code>WHERE</code> clauses or network APIs that return a cursor.</p> <p>Tiling however is concurrent. It attempts to fetch items for all it's active queries simultaneously. Therefore, to use tiling with key set or cursor based APIs, use the <code>neighboredQueryFetcher</code> method. It maintains a LIFO map of queries to tokens/cursors which lets active queries without an adjacent token/cursor <code>suspend</code> until one is available.</p>"},{"location":"usecases/pagination-types/#example_1","title":"Example","text":"<p>Consider an API which returns the cursor for the next page in the response body:</p> <pre><code>interface ProductRepository {\nfun productsFor(\nlimit: Int,\ncursor: String?\n): ProductsResponse\n}\ndata class ProductsResponse(\nval products: List&lt;Product&gt;,\nval nextPage: String\n)\n</code></pre> <p>A tiled <code>QueryFetcher</code> for it can be set up as follows:</p> <pre><code>data class ProductQuery(\n// Keep track of the current page within the query\nval page: Int,\nval limit: Int = 20,\n)\nfun productQueryFetcher(\nproductRepository: ProductRepository\n): QueryFetcher&lt;ProductQuery, Product&gt; = neighboredQueryFetcher(\n// 5 tokens are held in a LIFO queue\nmaxTokens = 5,\n// Make sure the first page has an entry for its cursor/token\nseedQueryTokenMap = mapOf(ProductQuery(page = 0) to null),\nfetcher = { query, cursor -&gt;\nval productsResponse = ProductRepository.productsFor(\nlimit = query.limit,\ncursor = cursor\n)\nflowOf(\nNeighboredFetchResult(\n// Set the cursor for the next page and any other page with data available.\n// This will cause the fetcher for the pages to be invoked if they are in scope.\nmapOf(ProductQuery(page = 1) to productsResponse.nextPage),\nitems = productsResponse.products\n)\n)\n}\n)\n</code></pre> <p>Note</p> <p>Tiling with cursors requires that the first query be seeded in the <code>seedQueryTokenMap</code> argument. Without this, all queries will suspend indefinitely as there is no starting query to initialize tiling.</p> <p>The above can then be used in any other tiled paging pipeline:</p> <pre><code>class ProductState(\nrepository: ProductRepository\n) {\nprivate val requests = MutableStateFlow(0)\nprivate val comparator = compareBy(ProductQuery::page)\nval products: StateFlow&lt;TiledList&lt;ProductQuery, Product&gt;&gt; = requests\n.map { ProductQuery(page = it) }\n.toPivotedTileInputs&lt;Int, FeedItem&gt;(\nPivotRequest(\nonCount = 5,\noffCount = 2,\ncomparator = comparator,\nnextQuery = {\ncopy(page + 1)\n},\npreviousQuery = {\nif (page &gt; 0) copy(page - 1)\nelse null\n}\n)\n)\n.toTiledList(\nlistTiler(\n// Start by pivoting around 0\norder = Tile.Order.PivotSorted(\nquery = PageQuery(page = 0),\ncomparator = comparator\n),\n// Limit to only 3 pages of data in UI at any one time, so 90 items\nlimiter = Tile.Limiter(\nmaxQueries = 3,\nitemSizeHint = null,\n),\nfetcher = productQueryFetcher(repository)\n)\n)\n.stateIn(/*...*/)\nfun setVisiblePage(page: Int) {\nrequests.value = page\n}\n}\n</code></pre> <p>Note</p> <p>The caveats of key set or cursor based paging still apply while tiling; page jumping is not supported. Requesting a page that has no cursor will suspend indefinitely unless a cursor is provided. This means for dynamic paging pipelines like search, at least one query must emit a cursor for new incoming queries. Alternatively, a new tiling pipeline may be assembled.</p> <p>In the cases where queries change fundamentally where key sets or cursors are invalidated, you will have to create a new <code>ListTiler</code>. However since tiling ultimately produces a <code>List&lt;Item&gt;</code>, distinct tiling pipeline can be seamlessly flatmapped into each other. To maintain a good user experience, the user's current visible range should be found in the new pipeline so the new pipeline can be started around the user's current position.</p>"},{"location":"usecases/placeholders/","title":"Placeholders","text":"<p>The following guide helps create the UI/UX seen below:</p> <p> </p> <p>The code for the above can be seen in the Musify Spotify clone, on the Podcast episode detail screen.</p>"},{"location":"usecases/placeholders/#guide","title":"Guide","text":"<p>When loading data from asynchronous sources, it is sometimes required to show static data first. Since tiling exposes a <code>List</code>, inserting placeholders typically involves emitting the placeholder items first.</p> <p>Consider the following repository that fetches a list of podcast episodes from the network with paginated offsets:</p> <pre><code>private const val LIMIT = 20\n/**\n * A query for tracks at a certain offset\n */\ndata class PodcastEpisodeQuery(\nval offset: Int,\nval limit: Int = LIMIT,\n)\ninterface PodcastEpisodeRepository {\nsuspend fun episodesFor(query: PodcastEpisodeQuery): List&lt;Track&gt;\n}\n</code></pre> <p>The above can be represented in the UI with a sealed class hierarchy for presentation:</p> <pre><code>sealed class PodcastEpisodeItem {\ndata class Placeholder(\nval key: String,\n) : PodcastEpisodeItem()\ndata class Loaded(\nval key: String,\nval track: Track,\n) : PodcastEpisodeItem()\n}\n</code></pre> <p>The tiling pipeline can then be used to emit placeholders immediately, then the actual items can then be fetched asynchronously.</p> <pre><code>fun tiledPodcastEpisodes(\nstartQuery: PodcastEpisodeQuery,\nqueries: Flow&lt;PodcastEpisodeQuery&gt;,\nrepository: PodcastEpisodeRepository,\n): Flow&lt;TiledList&lt;PodcastEpisodeQuery, PodcastEpisodeItem&gt;&gt; = queries\n.toPivotedTileInputs(\nPivotRequest&lt;PodcastEpisodeQuery, PodcastEpisodeItem&gt;(\nonCount = 5,\noffCount = 4,\ncomparator = compareBy(TrackQuery::offset),\nnextQuery = {\ncopy(offset = offset + limit)\n},\npreviousQuery = {\nif (offset == 0) null\nelse copy(offset = offset - limit)\n},\n)\n)\n.toTiledList(\nlistTiler(\norder = Tile.Order.PivotSorted(\nquery = startQuery,\ncomparator = compareBy(TrackQuery::offset)\n),\nlimiter = Tile.Limiter(\nmaxQueries = 3\n),\nfetcher = { query -&gt;\nflow {\nval keys = (query.offset until (query.offset + query.limit))\n// emit all placeholders first\nemit(keys.map(PodcastEpisodeItem::Placeholder))\n// Fetch tracks asynchronously\nval episodes = repository.episodesFor(query)\n// if the repository returns a `Flow`, `emitAll` can be used instead\nemit(\nepisodes.mapIndexed { index, track -&gt;\nPodcastEpisodeItem.Loaded(\n// Make sure the loaded items and placeholders share the same keys\nkey = keys[index],\ntrack = track,\n)\n}\n)\n}\n// A basic retry strategy if the network fetch fails\n.retry(retries = 10) { e -&gt;\ne.printStackTrace()\n// retry on any IOException but also introduce delay if retrying\nval shouldRetry = e is IOException\nif (shouldRetry) delay(1000)\nshouldRetry\n}\n// If the network is unavailable, nothing may be emitted\n.catch { emit(emptyTiledList&lt;PodcastEpisodeQuery, PodcastEpisodeItem&gt;()) }\n}\n)\n)\n</code></pre>"},{"location":"usecases/search/","title":"Search","text":"<p>The following guide helps create the UI/UX seen below:</p> <p> </p> <p>The code for the above can be seen in the Musify Spotify clone, on the search screen.</p>"},{"location":"usecases/search/#guide","title":"Guide","text":"<p>Tiling provides data as a continuous stream, so search can be easily implemented without losing items that were previously fetched by debouncing as the queries change.</p> <p>Consider a paginated API that allows that allows for filtering results that matches a query:</p> <pre><code>private const val LIMIT = 20\n/**\n * A query for tracks at a certain offset matching a query\n */\ndata class TracksQuery(\nval matching: String,\nval offset: Int,\nval limit: Int = LIMIT,\n)\ninterface TracksRepository {\nsuspend fun tracksFor(query: TracksQuery): List&lt;Track&gt;\n}\n</code></pre> <p>Tracks can be fetched by:</p> <ul> <li>Debouncing the query to account for user typing</li> <li>Debouncing the output when the output <code>TiledList</code> is empty or doesn't have all the requested pages available to allow for item add/remove/move animations.</li> </ul> <pre><code>fun tiledTracks(\nstartQuery: TracksQuery,\nqueries: Flow&lt;TracksQuery&gt;,\nrepository: TracksRepository,\n): Flow&lt;TiledList&lt;TracksQuery, Track&gt;&gt; =\nqueries.debounce {\n// Don't debounce the if its the first character or more is being loaded\nif (it.matching.length &lt; 2 || it.offset != startQuery.offset) 0\n// Debounce for key input\nelse 300\n}\n.toPivotedTiledInputs(\nPivotRequest&lt;TracksQuery, TrackItem&gt;(\nonCount = 5,\noffCount = 4,\ncomparator = compareBy(TrackQuery::offset),\nnextQuery = {\ncopy(offset = offset + limit)\n},\npreviousQuery = {\nif (offset == 0) null\nelse copy(offset = offset - limit)\n},\n)\n)\n.toTiledList(\nlistTiler(\norder = Tile.Order.PivotSorted(\nquery = startQuery,\ncomparator = compareBy(TrackQuery::offset)\n),\nlimiter = Tile.Limiter(\nmaxQueries = 3\n),\nfetcher = { query -&gt;\nflow { emit(repository.tracksFor(query)) }\n}\n)\n)\n.debounce { tiledItems -&gt;\n// If empty, or has a few pages of data the search query might have just changed.\n// Allow items to be fetched for item position animations\nif (tiledItems.isEmpty() || tiledItems.tileCount &lt; 3) 350L\nelse 0L\n}\n</code></pre>"},{"location":"usecases/transformations/","title":"Transformations","text":"<p>There are extensions on <code>TiledList</code> that offer many standard library like transformations to allow for easy <code>TiledList</code> modification. These include:</p> <ul> <li><code>TiledList.map()</code> and <code>TiledList.mapIndexed()</code></li> <li><code>TiledList.filter()</code>, <code>TiledList.filterIndexed()</code> and <code>TiledList.filterisInstance()</code></li> <li><code>TiledList.distinct()</code> and <code>TiledList.distinctBy()</code></li> <li><code>TiledList.groupBy()</code></li> </ul>"},{"location":"usecases/transformations/#generic-transformations","title":"Generic transformations","text":"<p>For transformations outside of this, a <code>buildTiledList</code> method that offers semantics identical to the Kotlin standard library <code>buildList</code> is also available.</p> <p>This method is most applicable to additive modifications like adding separators, or other miscellaneous items at arbitrary indices.</p>"}]}